const { GoogleGenerativeAI } = require("@google/generative-ai");

class AIService {
  constructor() {
    this.apiKey = process.env.GEMINI_API_KEY;
    
    if (!this.apiKey) {
      console.warn('Warning: GEMINI_API_KEY not found in environment variables. AI service will be disabled.');
      this.genAI = null;
    } else {
      this.genAI = new GoogleGenerativeAI(this.apiKey);
    }
  }


  async generateDriverInsights(driverData) {
    if (!this.genAI) {
      throw new Error('Gemini AI service is not configured. Please provide a GEMINI_API_KEY.');
    }

    try {
      const model = this.genAI.getGenerativeModel({ model: "gemini-2.0-flash" });
      const prompt = this.buildDriverInsightPrompt(driverData);
      
      const result = await model.generateContent(prompt);
      const response = await result.response;

      if (!response || !response.text()) {
        throw new Error('Received an empty response from the AI service.');
      }

      const aiResponse = response.text().trim();
      console.log('AI Response:', aiResponse);

      // Try to parse the JSON response
      try {
        let cleanResponse = aiResponse;
        if (aiResponse.includes('```json')) {
          cleanResponse = aiResponse.replace(/```json\s*|\s*```/g, '');
        } else if (aiResponse.includes('```')) {
          cleanResponse = aiResponse.replace(/```\s*|\s*```/g, '');
        }

        const jsonMatch = cleanResponse.match(/\{[\s\S]*\}/);
        if (jsonMatch) {
          const insights = JSON.parse(jsonMatch[0]);
          return this.formatInsightsToString(insights);
        } else {
          // Try parsing the entire cleaned response
          const insights = JSON.parse(cleanResponse.trim());
          return this.formatInsightsToString(insights);
        }
      } catch (parseError) {
        console.warn('Failed to parse AI JSON response:', parseError.message);
        console.warn('Raw response:', aiResponse);
        
        const fallback = {
          overall: 'AI analysis temporarily unavailable. Driver performance appears within normal parameters.',
          strengths: 'Unable to generate detailed analysis at this time.',
          recommendations: 'Please try again later or contact system administrator.',
          risk: 'No significant risks identified based on available data.'
        };
        return this.formatInsightsToString(fallback);
      }

    } catch (error) {
      console.error('Gemini AI Service Error:', error.message);
      
      const fallbackInsights = {
        overall: 'AI service temporarily unavailable. Driver performance data retrieved successfully.',
        strengths: 'Please review driver metrics manually or try again later.',
        recommendations: 'Contact system administrator if this issue persists.',
        risk: 'Unable to assess risks automatically at this time.'
      };
      return this.formatInsightsToString(fallbackInsights);
    }
  }




  formatInsightsToString(insights) {
    return `
DRIVER PERFORMANCE ANALYSIS 

Overall Performance:
${insights.overall}

Strengths & Areas for Improvement:
${insights.strengths}

Recommendations:
${insights.recommendations}

Risk Assessment:
${insights.risk}

Generated by AI Transportation Analyst`.trim();
  }

  getSystemInstructions() {
    return `You are a transportation analyst. Analyze driver performance data and provide actionable insights for fleet managers.

Focus on:
- Performance strengths and improvement areas
- Specific recommendations for drivers/managers
- Safety, efficiency, and reliability factors
- Professional, concise analysis (1-2 paragraphs max)`;
  }

  
  buildDriverInsightPrompt(driverData) {
    const { driver, summary, ratings, recentDeliveries } = driverData;
    
    // Build driver information section
    const driverInfo = [
      `DRIVER: ${driver.name} (${driver.type === 'transporter' ? 'External' : 'In-House'})`,
      `Company: ${driver.transportCompany || 'N/A'} | Deliveries: ${driver.totalDeliveries || 'N/A'} | Experience: ${this.calculateExperience(driver.createdAt)}`,
      '',
      'RATINGS:',
      `Overall: ${summary.averageOverall}/5 (${summary.totalRatings} ratings)`,
      `Punctuality: ${summary.averagePunctuality}/5`,
      `Professionalism: ${summary.averageProfessionalism}/5`,
      `Quality: ${summary.averageDeliveryQuality}/5`,
      `Communication: ${summary.averageCommunication}/5`
    ];

    // Add safety rating if available
    if (summary.averageSafety > 0) {
      driverInfo.push(`Safety: ${summary.averageSafety}/5`);
    }

    // Build feedback section
    const feedbackSection = [];
    if (ratings && ratings.length > 0) {
      feedbackSection.push('', 'RECENT FEEDBACK:');
      
      const recentRatingsWithComments = ratings
        .filter(r => r.comments && r.comments.trim())
        .slice(0, 2);
        
      if (recentRatingsWithComments.length > 0) {
        recentRatingsWithComments.forEach((rating, index) => {
          feedbackSection.push(`${index + 1}. "${rating.comments}" (${rating.overallRating}/5)`);
        });
      } else {
        feedbackSection.push('No recent feedback available.');
      }
    }

    // Build deliveries section
    const deliveriesSection = [];
    if (recentDeliveries && recentDeliveries.length > 0) {
      deliveriesSection.push('', 'RECENT DELIVERIES:');
      recentDeliveries.slice(0, 2).forEach((delivery, index) => {
        deliveriesSection.push(`${index + 1}. ${delivery.request.origin} → ${delivery.request.destination} (${delivery.request.truckCount}→${delivery.actualTruckCount} trucks)`);
      });
    }

    // Build final prompt
    const promptSections = [
      this.getSystemInstructions(),
      '',
      ...driverInfo,
      ...feedbackSection,
      ...deliveriesSection,
      '',
      'Analyze and return ONLY valid JSON:',
      '{',
      '  "overall": "Brief performance summary",',
      '  "strengths": "Key strengths and improvement areas",',
      '  "recommendations": "Specific actionable recommendations",',
      '  "risk": "Risk assessment and concerns"',
      '}'
    ];

    return promptSections.join('\n');
  }

  /**
   * Calculate driver experience based on creation date.
   * This helper function remains unchanged.
   */
  calculateExperience(createdAt) {
    if (!createdAt) return 'Unknown';
    
    const created = new Date(createdAt);
    const now = new Date();
    const diffTime = Math.abs(now - created);
    const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
    
    if (diffDays < 30) {
      return `${diffDays} days`;
    } else if (diffDays < 365) {
      const months = Math.floor(diffDays / 30);
      return `${months} month${months > 1 ? 's' : ''}`;
    } else {
      const years = Math.floor(diffDays / 365);
      const remainingMonths = Math.floor((diffDays % 365) / 30);
      let experience = `${years} year${years > 1 ? 's' : ''}`;
      if (remainingMonths > 0) {
        experience += `, ${remainingMonths} month${remainingMonths > 1 ? 's' : ''}`;
      }
      return experience;
    }
  }

  /**
   * Test the AI service connection by sending a simple prompt.
   */
  async testConnection() {
    if (!this.genAI) {
        return { success: false, message: 'AI Service is not configured (missing API key).' };
    }
    try {
      const model = this.genAI.getGenerativeModel({ model: "gemini-1.5-flash" });
      const result = await model.generateContent("Hello");
      const response = await result.response;
      if (response && response.text()) {
        return { success: true, message: 'Gemini AI service connected successfully.' };
      }
      throw new Error("Received an empty response during test.");
    } catch (error) {
      return { 
        success: false, 
        message: `Gemini AI service connection failed: ${error.message}` 
      };
    }
  }
}

module.exports = new AIService();
